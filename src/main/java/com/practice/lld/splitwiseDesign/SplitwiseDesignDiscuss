   Splitwise APP Design
   --------------------
ğŸ‘¨â€ğŸ’¼ ***** Interviewer â€” Problem Statement (Refined) ******
    Design an expense-sharing application similar to Splitwise.
    The system should allow users to create groups, add shared expenses, and compute balances for each user.

    âœ… Functional Requirements (LOCKED)
    1ï¸âƒ£ User & Group Management
        1. A user can:
            * Create a group
            * Join a group
        2. Each group has:
            * One admin
            * Multiple members
        3. Only the group admin can:
            * Add members
            * Remove members

    2ï¸âƒ£ Expense Management
        1. Any group member can:
            * Add an expense to the group
            * Edit an expense they created
        2. An expense has:
            * Amount
            * Paid by (one or more users)
            * Split among:
                * All group members OR
                * Selected members
        3. Supported split types:
            * Equal split
            * Exact amount split
            * Percentage split

    3ï¸âƒ£ Balance Calculation
        1. The system should:
            * Track how much each user owes and is owed
        2. After every expense update:
            * User balances should be recalculated
        3. Users should be able to:
            * View their net balance (overall)
            * View balances group-wise

    4ï¸âƒ£ Settlement
        1. A user can:
            * Settle up with another user
        2. Settlement:
            * Reduces outstanding balances
            * Does not delete expense history

    âŒ Out of Scope (Explicitly)
        * Real payment gateway
        * Currency conversion
        * Notifications
        * Fraud detection
        * Multiple devices sync

    âš™ï¸ Non-Functional Requirements (IMPORTANT)
        1. System should be:
            * Thread-safe
            * Handle concurrent expense additions
        2. Expenses should support:
            * Notes / description
            * Comments by group members
        3. The system should:
            * Maintain an audit log of activities (expense added, edited, settled)
        4. Design should be:
            * Extensible
            * Clean LLD-focused (not DB schema heavy)

ğŸ”’ Assumptions (Locked)
    * Single service (no microservices)
    * In-memory storage
    * Single currency
    * Single JVM

ğŸ§  Interviewer Notes (Why This Structure Works)
âœ” Clear entitiesâœ” Clear workflowsâœ” No ambiguityâœ” Easy to ask follow-up questionsâœ” Perfect for SDE-2 LLD
    This is exactly how the problem is framed in interviews at:
    * Flipkart
    * Uber
    * Amazon
    * Razorpay
    * PhonePe
    * Swiggy

ğŸ‘¨â€ğŸ’¼ Interviewer â€” Next Step
â€œLooks good.â€¨Please start with your design approach:
* Core workflow
* Entity identification
* Key classes and responsibilitiesâ€
Whenever youâ€™re ready, start with Step 1.



***** Solution **********
1. Core Workflow
   => i will divide the workflow into subModule
      a. group Formation
         user -> register -> form group-> add Members/Invite members/remove member -> becomes Admin -> group formed

      b. Expense Managements
         user -> Add/edit expense(expense:-  name, desc)  -> split the expense (Multiple strategies here: equal split, percentage split, amount split)
        -> update the balances of the group members(calculate each member balance like owes or owe, group wise balance like total expenses)

      c. Settlement:
         outstanding amount will be settled among group members

2. Entity/Object Identification:
   1. group Formation
        a. user
        b. userType (Enum)
        c. group
        d. groupController
   2. Expense Management
        a. Expense
        b. ExpenseSplitStrategy
        c. concrete classes for ExpenseSplitStrategy
        d. UserBalance
           : main objective of this to keep track of other members owing me, Map<userId(Int), amount(double)>
        e. ExpenseManager : this will manage all the expense related methods/actions , like an orchestrator for expense

   d. settlement
        a. we can use the above classes or entities to manage this one as well


   e. orchestrator:
      SplitwiseService: groupController, ExpenseManager, ExpenseSplitStrategy



 3. Key classes and responsibilitiesâ€
     a. user
        + id
        + name
        + type
     b. userType (Enum)
        + ADMIN, USER, SUPER_USER (group based admin)

     c. group
        + id
        + desc
        + List<userId> users
        + active: bool

     d. groupController
        + add/remove user
        + inviteMember()
        + getGroupLink()

     e. Expense
         + expenseId
         + amount: double
         + desc: string
         + groupId: int
         + List<Comment> comments; // Non functional
         + addedBy : userId

     f. ExpenseSplitStrategy
         + Split(expense: Expense)

     g. Concrete classes for Expense Split strategy:
         + EqualExpenseSplitStrategy
         + percentageSplitStrategy
         + AmountBasedSplitStrategy

     h. UserBalance
        + userId
        + Map<userId:Int, amountPending: String> amountOweByGroupMembers
        + grpId

     i. ExpenseManager
         + addExpense(ExpenseRequest)
         + updateExpense(ExpenseRequest)
         + deleteExpense(ExpenseId)
         + calculateBalance()
         + settleOutstandingDues()

     j. ExpenseRequest: POJO
         + amount
         + userId
         + strategy
         + desc
         + grpId

      h. ExpenseMgmtService: Orchestrator
         + ExpenseManager expenseManager
         + GroupController groupController
         + ExpenseSplitStrategy strategyToUse



   Chat gpt feedback:

   Great attempt ğŸ‘â€¨Your thinking direction is correct, and this is already SDE-2 level.â€¨Now Iâ€™ll do exactly what you asked:
   1. âœ… Review your happy-path design
   2. ğŸ§  Deep-dive the concurrency & balance part (very clearly, practically, and interview-ready)
   3. ğŸ”§ Refine / correct the model where needed
   4. ğŸ“Œ Give you a clean, final â€œinterview-qualityâ€ design you can keep as notes
   Iâ€™ll not redesign everything from scratch â€” Iâ€™ll evolve your solution.

   1ï¸âƒ£ High-Level Review of Your Design (Happy Path)
   âœ… What You Did Well
   * Correct module breakdown (Group, Expense, Settlement)
   * Correct use of Strategy Pattern for splitting
   * Good instinct to introduce:
       * ExpenseManager
       * Orchestrator (SplitwiseService)
   * You separated:
       * Expense creation
       * Balance calculation
       * Settlement
   ğŸ‘‰ This is already how an interviewer expects you to think.

   âš ï¸ Key Gaps (Important)
   Iâ€™ll fix these:
   1. Balance model is slightly incorrect
   2. Settlement logic needs clarity
   3. Concurrency needs a proper mental + implementation model
   4. Some enums / responsibilities can be simplified

   2ï¸âƒ£ Core Concept You MUST Nail in Splitwise
   Splitwise is NOT about expenses.â€¨It is about balances between users.
   Expenses are events.â€¨Balances are state.
   This one line is gold in interviews.

   3ï¸âƒ£ Correct Balance Model (Very Important)
   âŒ Your Current Model
   Map<userId, amountPending>
   This is directionally okay but incomplete.

   âœ… Correct Mental Model
   For every group, maintain:
   â€œWho owes whom, and how much?â€
   ğŸ”‘ Balance Representation (Industry-Standard)
   Map<UserId, Map<UserId, Double>>
   Meaning:
   balances[A][B] = X
   â†’ B owes A amount X
   âœ” Direction is explicitâ€¨âœ” Easy to settleâ€¨âœ” Easy to simplify

   ğŸ“Œ Example (Never Forget This)
   Expense:
   * Dinner = â‚¹300
   * Paid by A
   * Split among A, B, C
   Each owes = â‚¹100
   Balances:
   balances[A][B] = 100
   balances[A][C] = 100
   Thatâ€™s it.

   4ï¸âƒ£ Improved Entity Design (Minimal Changes)
   1. User
   class User {
       int id;
       String name;
   }
   No need for SUPER_USER â€” group admin can be managed at group level.

   2. Group
   class Group {
       int id;
       String name;
       int adminUserId;
       Set<Integer> members;
       Map<Integer, Map<Integer, Double>> balances;
   }
   ğŸ‘‰ balances belong to Group, not Userâ€¨(Interviewers LOVE this)

   3. Expense
   class Expense {
       int expenseId;
       double amount;
       int groupId;
       int paidByUserId;
       String description;
       List<ExpenseSplit> splits;
   }

   4. ExpenseSplit
   class ExpenseSplit {
       int userId;
       double amount;
   }

   5. ExpenseSplitStrategy (Correct Usage)
   interface ExpenseSplitStrategy {
       List<ExpenseSplit> split(Expense expense, List<Integer> users);
   }
   Concrete:
   * EqualSplitStrategy
   * PercentageSplitStrategy
   * ExactAmountSplitStrategy
   âœ… Perfect use of Strategy pattern (you did this right)

   5ï¸âƒ£ ExpenseManager (Core Brain of System)
   class ExpenseManager {

       void addExpense(Expense expense) {
           List<ExpenseSplit> splits = strategy.split(expense);

           for (ExpenseSplit split : splits) {
               if (split.userId != expense.paidByUserId) {
                   updateBalance(
                       expense.paidByUserId,
                       split.userId,
                       split.amount
                   );
               }
           }
       }

       void updateBalance(int creditor, int debtor, double amount) {
           balances.get(creditor)
                   .put(debtor,
                        balances.get(creditor).getOrDefault(debtor, 0.0) + amount);
       }
   }

   6ï¸âƒ£ Settlement (Simple & Clean)
   Settle A â†” B
   void settle(int userA, int userB, int groupId) {
       double amount = balances.get(userA).getOrDefault(userB, 0.0);

       balances.get(userA).remove(userB);
       balances.get(userB).remove(userA);
   }
   âœ” No expense deletionâ€¨âœ” Just balance adjustment

   7ï¸âƒ£ ğŸ”¥ CONCURRENCY â€” Explained Clearly (This Is What You Asked For)
   This is where most candidates fail. You wonâ€™t.

   Problem to Solve
   * Multiple users add expenses at the same time
   * Balance updates must be consistent
   * No partial updates

   âŒ Wrong Approach
   synchronized addExpense()
   This blocks the entire system âŒ

   âœ… Correct, Interview-Ready Approach
   ğŸ§  Concept:
   Concurrency should be handled at GROUP level, not system level

   ğŸ¯ Solution: Per-Group Lock
   class Group {
       ReentrantLock lock = new ReentrantLock();
   }

   Expense Addition with Lock
   void addExpense(Expense expense) {
       Group group = groupRepo.get(expense.groupId);

       group.lock.lock();
       try {
           // calculate splits
           // update balances
           // store expense
       } finally {
           group.lock.unlock();
       }
   }

   Why This Is Perfect
   âœ” Users in different groups can add expenses concurrentlyâ€¨âœ” Users in same group are serializedâ€¨âœ” Easy to implementâ€¨âœ” Interviewers love this explanation

   â± Optional Enhancement (Bonus)
   * Optimistic locking using version numbers
   * DB-level row locks (if persistent)
   Mention only if asked.

   8ï¸âƒ£ Orchestrator (Clean & Interview-Friendly)
   class SplitwiseService {
       GroupController groupController;
       ExpenseManager expenseManager;

       void addExpense(ExpenseRequest request) {
           Expense expense = expenseMapper.map(request);
           expenseManager.addExpense(expense);
       }
   }

   9ï¸âƒ£ How to Explain This in Interview (Script)
   â€œExpenses are immutable events.â€¨Balances are the core state.â€¨I maintain balances per group using a directed graph-like structure.â€¨Concurrency is handled using per-group locking to avoid global contention.â€
   That sentence alone puts you in top 10%.

   ğŸ”’ Final Verdict
   âœ… Your design direction â†’ Correctâ€¨ğŸ”§ Needed refinements â†’ Balances & concurrencyâ€¨ğŸ¯ Final result â†’ Strong SDE-2 Splitwise LLD






