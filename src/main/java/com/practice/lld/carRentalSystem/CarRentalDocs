
Car Rental Design Docs
------------------------

System Requirements & Request flow & Request Gathering
-----------------------------------------
Problem Statement:
-> Design a Car Rental System similar to services like Zoomcar / Hertz / Avis.
   Design the car rental system with clean object-oriented design and explain your thought process.

Functional Requirements:
1. The system should allow **customers to search and rent cars**.
2. The system should support **multiple cities and multiple rental locations**.
3. Each rental location can have **multiple cars**.
4. Cars can be of **different types**:

   * Hatchback
   * Sedan
   * SUV
   * Luxury
5. Each car has:

   * Unique ID
   * License number
   * Type
   * Current status (AVAILABLE, BOOKED, MAINTENANCE)

---

## üîπ Booking Requirements

6. A customer should be able to:

   * Select pickup location
   * Select pickup date & time
   * Select drop date & time
   * Select car type
7. System should show **available cars** for the selected time range.
8. Once booked, the car should **not be available** for overlapping bookings.
9. A booking should generate a **reservation** with a unique ID.

---

## üîπ Pricing & Payment

10. Rental price should be calculated based on:

    * Duration
    * Car type
11. System should support **multiple payment modes**:

    * Credit Card
    * UPI
    * Net Banking
12. Payment can be:

    * Successful
    * Failed
    * Pending

---

## üîπ User & Admin

13. The system should support:

    * Customers
    * Admins
14. Admin should be able to:

    * Add/remove cars
    * Update car status
    * Manage rental locations

---

## üîπ Booking Lifecycle

15. A booking can be in states:

    * CREATED
    * CONFIRMED
    * CANCELLED
    * COMPLETED
16. Users should be able to **cancel bookings** (assume simple rules).

---

## üîπ Non-Functional Requirements (Mention Only)

17. The system should be:

    * Extensible
    * Scalable
    * Thread-safe (high-level mention only)

---

## üîπ Constraints & Assumptions

* Ignore real-time GPS tracking.
* Ignore discounts and promotions.
* Assume availability is calculated using time intervals.
* Focus on **Low Level Design**, not APIs or DB schemas.

---

## üéØ Interview Expectation

You are expected to:

* Identify entities
* Design class relationships
* Apply suitable design patterns
* Show extensibility
* Write **pseudo-code or partial Java code** if asked


Solution:
------------


 Users Object Identification:
 -----------------------------
 1. UserType: Enum
    + ADMIN, CLIENT, HOST (All three r diff authorized to manage the rental bookings)
    -> CLIENT : can only book the available rental cars, basically its a user
    -> HOST: they are the people who hosted their cars so they can modify the car availbility, add & remove cars based on locations.
    -> ADMIN: they are the Support staff who has the admin access to manage anything.

 2. UserInfo: Entity
    Attributes:
    + userId: Int
    + userName: String
    + userType: Enum
    + rentalAddress: Address
    + hostedCars: Map<CarId, Car> // applicable for host users
    + bookedCars: List<BookingInfo> // applicable for client users

 3. UserAddress: Entity
    Attributes:
    + userId: Int
    + city: String
    + pincode: String
    + state: String

 4. UserController : Class
    Objective: The reason to have this class is to not clutter the entities classes or POJO classes. This User controller will manage the user settings.
        a. add/remove rental car
        b. read/update rental car info
        c. get previous booking
        d. updateUserProfile
    Attributes:

    Methods:
    + updateRentalAddress(UserRequest request)
    + addRentalCar(addCarRequest request)
    + removeRentalCar(removeRentalCarRequest request)
    + getMyRentalCarInfo(UserRequest request)
    + updateRentalCarInfo(UserRequest request)
    + getBookingInfoById(BookingId)
    + getAllBooking(UserId)
    + updateUserProfile(UserRequest request)



  Vehicle Management Object/entity Identification
  -----------------------------------------

  0. VehicleType: Enum
     + CAR, JEEP, BIKE


  1. CarType (ENUM)
     SUV, HATCHBACK, SEDAN, LUXURY

  2. VehicleStatus(ENUM)
     BOOKED, MAINTENANCE, AVAILABLE

  3. VehicleInfo. (Entity)
   Attributes:
   + VehicleType: enum  // basically to make it scalable in future with other vehicle type renting
   + vehicleId : INT
   + LicenceNumber: String
   + CarType carType: ENUM
   + carStatus: VehicleStatus
   + ownerId: userId
   + vehiclePurchaseDate: LocalDate
   + distanceTravelled: in KM

    Methods:
     + calculateAgeOfThevehicle() // based on purchase date & current date, get me the age of this vehicle which ll further used for either search or pricing
     + getDistanceTravelled()

  4. VehicleController : Class
     Objectives:
         a. manages the Vehicle entities like change vehicleStatus,
         b. add/remove vehicle
         c. check the availability of vehicle
     Attributes:

     Methods:
      + updateCarStatus(CarStatus status) :
         {
             this.carStatus = status // update the status of the car
         }

      + updateCarInfo(UpdateCarRequest request)
      + deleteCarInfo(deleteRequest request)
      + checkVehicleAvailable(VehicleId: id)



  Booking Management Entity/Object Identification
  -----------------------------------------------
   1. BookingStatus/Booking LifeCycle (ENUM)
      +  CREATED, CONFIRMED, CANCELLED, COMPLETED

   2. BookingInfo (Class Entity):
      Attributes:
      + BookingId: Int
      + customerId: UserId
      + VehicleId: Int
      + bookingStatus: BookingStatus
      + BookingStartDateTimeStamp: LocalDateTime
      + BookingEndDateTimeStamp: LocalDateTime


   3. BookingController (Class)
      Attributes:

      Methods:
        + addBooking(UserRequest request)
        + getBookingInfo(Id: BookingId )
        + getDurationOfBooking(Id: BookingId )
        + updateBookingStatus(Id: BookingId )
        + getPickUpLocation(Id: BookingId ) -> use user profile to get the rental location,
             we can dynamically at runtime can get the rentalLocation from user profile, currently each user has one location. In future we can extend the capabilities to
             have the list<RentalLocation> for a host user so that they can manage multiple rental locations for pickup & drop
        + getDropLocation(Id: BookingId)
        + calculateBasePrice(Id: BookingId): based on duration, vehicle age, type of vehicle we. -> ? (we should not have this here as this controller should only
           care about booking related stuff & follows SRP. we ll move this in fareCalculation Strategy or context class)


    4. BookingRequest (POJO ) :-> request created by user to create a booking
       Attributes:
       + userId
       + VehicleId
       + BookingStartDateTs
       + bookingEndDateTs



     Payment Management Entity/Object Identification
     -------------------------------------
     1. FareCalculator (Context Class)
        Attributes:
          + FareCalculationStrategy fareStartegy -> Based on strategy design pattern.
          + PaymentStrategy payStrategy -> Based on strategy design pattern.

         Methods:
           + calculateFare(id: BookingId, fareStrategy: FareCalculationStrategy ) : Double
           + payAmount (amnt: Double, payStrategy: PaymentStrategy): Boolean


     2. FareCalculationStrategy (Interface)
        -> we can create multiple concrete classes based on this for fare calculator

     3. PaymentStrategy (Interface)
        ->  we can create multiple concrete classes based on this for diff payment process




      VehicleRentalManager: (Orchestrator class)
      --------------------------------------
      objectives:
        a.  who is responsible to centralize & manange the overall lifecycle of booking event
        b.   responsible to take the requests from the user & forward to the concerned modules
        c. Its like a Facade layer or bff layer which ll interact with the user




     Corrections/ REVIEW
     --------------------
    Great, this is a **solid first-pass solution** üëç
    I‚Äôll now do exactly what you asked: **review this as an interviewer + teacher**, correct it, and tell you **what to keep, what to fix, and how to present it better for an SDE-2 interview**.

    I‚Äôll structure the feedback into:

    1. Overall verdict
    2. High-level architectural feedback
    3. Section-wise detailed review
    4. Key design flaws / improvements
    5. What is missing
    6. How to refine this into an **interview-perfect answer**
    7. Final score & next steps

    ---

    ## 1Ô∏è‚É£ Overall Interviewer Verdict

    **Verdict:**
    You are **thinking like an SDE-2**, not a fresher.
    Your design shows:

    * Good domain understanding
    * Correct use of enums, controllers, strategies
    * Awareness of SRP and extensibility

    However:

    * You‚Äôve **over-modeled users**
    * Mixed **responsibilities between controllers**
    * Missed **core rental concepts (Location, Inventory, Availability window)**

    ### ‚≠ê Score (SDE-2 bar): **7.5 / 10**

    With refinement ‚Üí **8.5‚Äì9** (very strong).

    ---

    ## 2Ô∏è‚É£ High-Level Architecture Feedback (Important)

    ### ‚úÖ What you did RIGHT

    * Clear separation:

      * User
      * Vehicle
      * Booking
      * Payment
    * Correct instinct to introduce:

      * Strategy pattern (Fare, Payment)
      * Orchestrator (`VehicleRentalManager`)
    * Awareness of SRP (you even self-corrected fare calculation üëè)

    ### ‚ùå Main Architectural Issue

    You designed the system as **user-centric**, but **car rental systems are inventory-centric**.

    Interviewers expect this hierarchy:

    ```
    City
     ‚îî‚îÄ‚îÄ RentalLocation
           ‚îî‚îÄ‚îÄ VehicleInventory
                 ‚îî‚îÄ‚îÄ Vehicles
    ```

    Right now, vehicles are hanging off **users (HOST)** ‚Üí this is **not scalable**.

    ---

    ## 3Ô∏è‚É£ Detailed Review ‚Äì Section by Section

    ---

    ## üîπ User Design Review

    ### ‚úÖ Good

    * `UserType` enum is reasonable
    * Differentiation between CLIENT / HOST / ADMIN is realistic
    * `UserInfo` is clean

    ### ‚ùå Issues & Corrections

    #### üî¥ Problem 1: HOST owning vehicles directly

    ```java
    hostedCars: Map<CarId, Car>
    ```

    This is a **design smell**.

    Why?

    * Cars belong to **locations**, not users
    * A host can manage cars, but doesn‚Äôt *own the inventory graph*

    ‚úÖ **Correction**

    ```text
    User
    - userId
    - userType

    RentalLocation
    - locationId
    - city
    - vehicles
    - managedBy (HOST / ADMIN)
    ```

    HOST ‚Üí manages locations
    Vehicles ‚Üí belong to locations

    ---

    #### üî¥ Problem 2: UserController too powerful

    Your `UserController` does:

    * User profile
    * Vehicle CRUD
    * Booking reads

    This violates SRP.

    ‚úÖ **Correction**

    * `UserController` ‚Üí profile only
    * `VehicleController` ‚Üí vehicles
    * `BookingController` ‚Üí bookings

    The **orchestrator** coordinates them.

    ---

    ## üîπ Vehicle Management Review

    ### ‚úÖ Very Good Parts

    * VehicleType abstraction ‚Üí forward-thinking
    * VehicleStatus enum ‚Üí correct
    * VehicleInfo attributes ‚Üí realistic
    * Vehicle age & distance ‚Üí excellent for pricing

    This part is **strong**.

    ---

    ### ‚ùå Missing Concept: Inventory & Location

    You **must** introduce these:

    ```text
    RentalLocation
    - locationId
    - city
    - address
    - inventory

    VehicleInventory
    - Map<VehicleType, List<Vehicle>>
    ```

    Why interviewers expect this:

    * Availability search is location-based
    * Pricing varies by location
    * Scaling to cities requires this layer

    ---

    ## üîπ Booking Management Review

    ### ‚úÖ Strong Design

    * Booking lifecycle enum ‚Üí perfect
    * BookingInfo attributes ‚Üí correct
    * BookingRequest ‚Üí good abstraction

    You even caught your own SRP violation ‚Äî that‚Äôs a **very strong signal**.

    ---

    ### ‚ùå Missing Logic: Availability Window

    Right now:

    ```java
    checkVehicleAvailable(VehicleId)
    ```

    This is **not enough**.

    Availability depends on:

    * Vehicle
    * Start time
    * End time

    ‚úÖ **Correction**

    ```java
    checkAvailability(vehicleId, startTs, endTs)
    ```

    Internally:

    * Validate no overlapping bookings

    Interviewers **will ask this**.

    ---

    ## üîπ Payment & Fare Design Review

    ### ‚úÖ Excellent Use of Strategy Pattern

    This is one of the **best parts** of your design.

    * `FareCalculationStrategy`
    * `PaymentStrategy`
    * Context class (`FareCalculator`)

    This is **textbook SDE-2**.

    Small improvement:

    * Separate Payment from Fare

    ```text
    FareService
    PaymentService
    ```

    Mentioning this is enough.

    ---

    ## üîπ VehicleRentalManager (Orchestrator)

    ### ‚úÖ Very Good Instinct

    You correctly identified the need for:

    * A facade / BFF layer
    * Central coordination

    This is **exactly what interviewers want**.

    ### üîß Suggested Responsibilities

    ```text
    VehicleRentalManager
    - searchVehicles()
    - createBooking()
    - confirmBooking()
    - cancelBooking()
    - initiatePayment()
    ```

    Controllers stay dumb, manager stays smart.

    ---

    ## 4Ô∏è‚É£ What Is Missing (Important)

    These are **expected at SDE-2**:

    ### üî¥ 1. Search Service

    How does a user find cars?

    ```text
    SearchCriteria
    - city
    - startTime
    - endTime
    - vehicleType
    ```

    ```text
    SearchService
    - searchAvailableVehicles(criteria)
    ```

    ---

    ### üî¥ 2. Time Overlap Logic (Mention)

    You don‚Äôt need to code it, but say:

    > ‚ÄúAvailability is checked using interval overlap validation.‚Äù

    ---

    ### üü° 3. Concurrency (Mention Only)

    Say:

    > ‚ÄúBooking confirmation must be atomic to avoid double booking.‚Äù

    No implementation needed.

    ---

    ## 5Ô∏è‚É£ How to Present This Better in Interview

    ### ‚ùå What to Avoid

    * Listing too many controllers
    * Explaining host logic too deeply
    * Over-explaining enums

    ---

    ### ‚úÖ Ideal Interview Flow (Use This)

    1. Clarify scope (no GPS, no discounts)
    2. Identify core entities
    3. Explain inventory & booking flow
    4. Apply strategy pattern
    5. Show orchestrator
    6. Mention extensions

    ---

    ### üé§ High-Impact Interview Line

    > ‚ÄúInventory and availability are location-centric, bookings are time-centric, and pricing is strategy-driven.‚Äù

    This sounds **senior**.

    ---

    ## 6Ô∏è‚É£ Final Score & Teacher Feedback

    ### ‚úÖ Strengths

    * Good domain modeling
    * Correct design patterns
    * SRP awareness
    * Implementation-ready thinking

    ### ‚ùå Needs Improvement

    * Inventory & location modeling
    * Overpowered UserController
    * Availability logic clarity

    ### ‚≠ê Final Score

    **7.5 / 10 ‚Üí Very close to strong SDE-2**





     Correct Version
     ---------------
# üöó Car Rental System ‚Äî Final Corrected LLD (SDE-2 Ready)

---

## Step 1: Requirement Gathering & System Workflow

### 1.1 Action Flow

1. User searches for cars by **city, date range, car type**.
2. System shows **available vehicles**.
3. User selects a car and creates a booking.
4. System blocks the vehicle for the selected time window.
5. User completes payment.
6. Booking is confirmed.
7. Vehicle status updates accordingly.
8. After trip completion, booking is closed and vehicle becomes available.

---

### 1.2 Functional Requirements

#### Core

1. Multiple cities and rental locations.
2. Multiple vehicles per location.
3. Different car types (SUV, Sedan, Hatchback, Luxury).
4. Users can:

   * Search cars
   * Book cars
   * Cancel bookings
5. Vehicles cannot be double-booked for overlapping time windows.
6. Pricing depends on:

   * Duration
   * Car type
   * Vehicle age (optional)
7. Multiple payment methods supported.

#### Users

* CLIENT ‚Üí rents vehicles
* HOST ‚Üí manages vehicles at locations
* ADMIN ‚Üí full control

---

### 1.3 Non-Functional (Mention Only)

* Scalable
* Extensible
* Thread-safe booking confirmation

---

## Step 2: Core Entity / Object Identification

### Domain Objects

1. User
2. RentalLocation
3. Vehicle
4. VehicleInventory
5. Booking
6. Payment

### Controllers / Services

7. SearchService
8. BookingService
9. PaymentService
10. VehicleService

### Orchestrator

11. VehicleRentalManager (Facade / BFF)

### Enums / Strategies

12. UserType
13. VehicleType
14. VehicleStatus
15. BookingStatus
16. FareCalculationStrategy
17. PaymentStrategy

---

## Step 3: Class Design & Responsibilities

---

## 3.1 User

```java
class User {
    int userId;
    String name;
    UserType userType; // CLIENT, HOST, ADMIN
}
```

‚úî No vehicles or bookings inside User
‚úî Keeps entity clean

---

## 3.2 RentalLocation (CRITICAL FIX)

```java
class RentalLocation {
    int locationId;
    String city;
    String address;
    VehicleInventory inventory;
}
```

üëâ **Vehicles belong to locations, not users**
This is a key SDE-2 expectation.

---

## 3.3 VehicleInventory

```java
class VehicleInventory {
    Map<VehicleType, List<Vehicle>> vehicles;

    List<Vehicle> getAvailableVehicles(
        VehicleType type,
        LocalDateTime start,
        LocalDateTime end
    ) {
        // filter vehicles by availability window
    }
}
```

---

## 3.4 Vehicle

```java
class Vehicle {
    int vehicleId;
    String licenseNumber;
    VehicleType type;
    VehicleStatus status;
    LocalDate purchaseDate;

    boolean isAvailable(LocalDateTime start, LocalDateTime end) {
        // check against existing bookings
    }
}
```

---

## 3.5 Booking

```java
class Booking {
    int bookingId;
    int userId;
    int vehicleId;
    int locationId;
    LocalDateTime startTime;
    LocalDateTime endTime;
    BookingStatus status;
}
```

---

## 3.6 BookingService

```java
class BookingService {

    Booking createBooking(BookingRequest request) {
        // 1. Validate availability
        // 2. Create booking with CREATED state
    }

    void confirmBooking(int bookingId) {
        // mark CONFIRMED
    }

    void cancelBooking(int bookingId) {
        // mark CANCELLED and release vehicle
    }
}
```

---

## 3.7 SearchService

```java
class SearchService {

    List<Vehicle> search(
        String city,
        VehicleType type,
        LocalDateTime start,
        LocalDateTime end
    ) {
        // fetch locations ‚Üí inventory ‚Üí available vehicles
    }
}
```

---

## 3.8 Pricing (Strategy Pattern)

```java
interface FareCalculationStrategy {
    double calculateFare(Booking booking);
}
```

```java
class DefaultFareStrategy implements FareCalculationStrategy {
    public double calculateFare(Booking booking) {
        // duration * baseRate
    }
}
```

---

## 3.9 Payment (Strategy Pattern)

```java
interface PaymentStrategy {
    boolean pay(double amount);
}
```

```java
class CreditCardPayment implements PaymentStrategy {
    public boolean pay(double amount) {
        return true;
    }
}
```

---

## 3.10 PaymentService

```java
class PaymentService {
    PaymentStrategy paymentStrategy;

    boolean processPayment(double amount) {
        return paymentStrategy.pay(amount);
    }
}
```

---

## 3.11 VehicleRentalManager (ORCHESTRATOR)

```java
class VehicleRentalManager {

    SearchService searchService;
    BookingService bookingService;
    PaymentService paymentService;
    FareCalculationStrategy fareStrategy;

    Booking rentVehicle(RentalRequest request) {
        Booking booking = bookingService.createBooking(request);

        double fare = fareStrategy.calculateFare(booking);
        boolean paid = paymentService.processPayment(fare);

        if (paid) {
            bookingService.confirmBooking(booking.bookingId);
        }

        return booking;
    }
}
```

üëâ Controllers stay focused
üëâ Manager coordinates lifecycle

---

## Step 4: Booking Availability Logic (Mention in Interview)

> ‚ÄúA vehicle is available if there is **no overlapping booking** for the requested time window.‚Äù

You **don‚Äôt need to code interval overlap**, just state it.

---

## Step 5: Design Principles Used

* **SRP** ‚Äì Clean entity separation
* **Strategy Pattern** ‚Äì Pricing & Payment
* **Facade Pattern** ‚Äì VehicleRentalManager
* **Open-Closed Principle** ‚Äì Easy extensions

---

## Step 6: Extensions (Mention Only)

* Dynamic pricing
* Discounts & coupons
* Loyalty points
* Multi-city trips
* Damage & insurance handling

---

## üéØ Interview Closing Statement (VERY IMPORTANT)

> ‚ÄúThe system is inventory-centric, availability is time-window based, booking is transaction-driven, and pricing is strategy-based.‚Äù

This is **exactly what interviewers want to hear**.

---

## ‚≠ê Final Teacher Verdict

* Clean
* Scalable
* Interview-ready
* Java-friendly
* Strong SDE-2 answer

### ‚úÖ Final Score: **8.5 / 10**















